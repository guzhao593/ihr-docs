(window.webpackJsonp=window.webpackJsonp||[]).push([[151],{733:function(t,a,e){"use strict";e.r(a);var r=e(30),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"mysql设计开发规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql设计开发规范"}},[t._v("#")]),t._v(" MySQL设计开发规范")]),t._v(" "),e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#一-数据库规约"}},[t._v("(一) 数据库规约")])]),e("li",[e("a",{attrs:{href:"#二-建表规约"}},[t._v("(二) 建表规约")])]),e("li",[e("a",{attrs:{href:"#三-索引建立基本原则"}},[t._v("(三) 索引建立基本原则")])]),e("li",[e("a",{attrs:{href:"#四-索引规约"}},[t._v("(四) 索引规约")])]),e("li",[e("a",{attrs:{href:"#五-sql语句"}},[t._v("(五) SQL语句")])]),e("li",[e("a",{attrs:{href:"#六-orm映射"}},[t._v("(六) ORM映射")])]),e("li",[e("a",{attrs:{href:"#七-参考文献"}},[t._v("(七) 参考文献")])])])]),e("p"),t._v(" "),e("h2",{attrs:{id:"一-数据库规约"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-数据库规约"}},[t._v("#")]),t._v(" (一) 数据库规约")]),t._v(" "),e("h4",{attrs:{id:"_1-【强制】统一使用innodb存储引擎-utf8字符集编码，排序规则统一为utf8-general-ci，特殊emoji表情的可以在表级别使用utf8mb4-字符集；"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-【强制】统一使用innodb存储引擎-utf8字符集编码，排序规则统一为utf8-general-ci，特殊emoji表情的可以在表级别使用utf8mb4-字符集；"}},[t._v("#")]),t._v(" 1. 【强制】统一使用INNODB存储引擎,UTF8字符集编码，排序规则统一为utf8_general_ci，特殊emoji表情的可以在表级别使用utf8mb4 字符集；")]),t._v(" "),e("p",[t._v("说明：UTF8 编码是Mysql数据库的标准流行字符集，能兼容中文GBK和西欧、日文字符以及特殊字符。")]),t._v(" "),e("h4",{attrs:{id:"_2-【强制】不支持trigger，存储过程，函数、视图；"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-【强制】不支持trigger，存储过程，函数、视图；"}},[t._v("#")]),t._v(" 2. 【强制】不支持trigger，存储过程，函数、视图；")]),t._v(" "),e("p",[t._v("说明：1）Mysql的存储过程性能和功能没有Oracle那么强；2）Mysql不容易存储过程断点调试；3）存储过程里面的慢sql目前无法跟踪；4）若以后应用扩展拆库拆表，业务逻辑写死在存储过程里，无法进行扩展；")]),t._v(" "),e("h4",{attrs:{id:"_3-【强制】不支持使用外键；"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-【强制】不支持使用外键；"}},[t._v("#")]),t._v(" 3. 【强制】不支持使用外键；")]),t._v(" "),e("p",[t._v("说明：Mysql是在索引级别加锁，外键会对子表对应的母表的外键字段加载S锁，堵塞母表的DML操作，严重时会发生交叉死锁")]),t._v(" "),e("h4",{attrs:{id:"_4-【强制】表必须有主键，非特殊业务需求下，建议使用由全局发生器生成的long型主键，不建议直接使用数据库自增主键（有安全隐患和数据维护麻烦）；"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-【强制】表必须有主键，非特殊业务需求下，建议使用由全局发生器生成的long型主键，不建议直接使用数据库自增主键（有安全隐患和数据维护麻烦）；"}},[t._v("#")]),t._v(" 4. 【强制】表必须有主键，非特殊业务需求下，建议使用由全局发生器生成的Long型主键，不建议直接使用数据库自增主键（有安全隐患和数据维护麻烦）；")]),t._v(" "),e("p",[t._v("说明：MySQL Innodb 索引组织表，聚集索引，相比字符串主键，增长型数字主键，性能更高，可以减少页分裂，同时可以减少表的二级索引的占用空间，还可以使用自增ID来做分页优化。")]),t._v(" "),e("h4",{attrs:{id:"_5-【推荐】uuid-，user-这样的mysql-inside函数对于主从复制来说是很危险的，会导致主备数据不一致。禁止使用。如果一定要使用uuid，让应用程序来产生。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-【推荐】uuid-，user-这样的mysql-inside函数对于主从复制来说是很危险的，会导致主备数据不一致。禁止使用。如果一定要使用uuid，让应用程序来产生。"}},[t._v("#")]),t._v(" 5. 【推荐】UUID()，USER()这样的MYSQL INSIDE函数对于主从复制来说是很危险的，会导致主备数据不一致。禁止使用。如果一定要使用UUID，让应用程序来产生。")]),t._v(" "),e("p",[t._v("说明：MySQL 低于5.7版本使用非row模式会存在bug,导致主备数据不一致问题,所以不建议大家使用\n虽然目前Mysql平台的主从复制方式是row模式，UUID函数不会造成主备数据库不一致，但容易受平台和将来版本的影响，不建议使用。5.7< 生产uuid 有bug")]),t._v(" "),e("h2",{attrs:{id:"二-建表规约"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-建表规约"}},[t._v("#")]),t._v(" (二) 建表规约")]),t._v(" "),e("h4",{attrs:{id:"_1-【强制】表达是与否概念的字段，必须使用is-xxx的方式命名，数据类型是-char-是否删除-y-n-数据类型是unsigned-tinyint（1表示是，0表示否）。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-【强制】表达是与否概念的字段，必须使用is-xxx的方式命名，数据类型是-char-是否删除-y-n-数据类型是unsigned-tinyint（1表示是，0表示否）。"}},[t._v("#")]),t._v(" 1. 【强制】表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是 char (是否删除 Y/N) 数据类型是unsigned tinyint（1表示是，0表示否）。")]),t._v(" "),e("p",[t._v("注意：POJO类中的任何布尔类型的变量，都不要加is前缀，所以，需要在"),e("code",[t._v("<resultMap>")]),t._v("设置从is_xxx到Xxx的映射关系。数据库表示是与否的值，使用tinyint类型，坚持is_xxx的命名方式是为了明确其取值含义与取值范围。\n正例：表达逻辑删除的字段名is_deleted，1表示删除，0表示未删除。")]),t._v(" "),e("h4",{attrs:{id:"_2-【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。"}},[t._v("#")]),t._v(" 2. 【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。")]),t._v(" "),e("p",[t._v("说明：MySQL在Windows下不区分大小写，但在Linux下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。\n正例：aliyun_admin，rdc_config，level3_name\n反例：AliyunAdmin，rdcConfig，level_3_name")]),t._v(" "),e("h4",{attrs:{id:"_3-【强制】表名不使用复数名词。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-【强制】表名不使用复数名词。"}},[t._v("#")]),t._v(" 3. 【强制】表名不使用复数名词。")]),t._v(" "),e("p",[t._v("说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。")]),t._v(" "),e("h4",{attrs:{id:"_4-【强制】禁用保留字，如desc、range、match、delayed等，请参考mysql官方保留字。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-【强制】禁用保留字，如desc、range、match、delayed等，请参考mysql官方保留字。"}},[t._v("#")]),t._v(" 4. 【强制】禁用保留字，如desc、range、match、delayed等，请参考MySQL官方保留字。")]),t._v(" "),e("h4",{attrs:{id:"_5-【强制】小数类型为decimal，禁止使用float和double。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-【强制】小数类型为decimal，禁止使用float和double。"}},[t._v("#")]),t._v(" 5. 【强制】小数类型为decimal，禁止使用float和double。")]),t._v(" "),e("p",[t._v("说明：float和double在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成整数和小数分开存储。")]),t._v(" "),e("h4",{attrs:{id:"_6-【强制】如果存储的字符串长度相等，使用char定长字符串类型。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-【强制】如果存储的字符串长度相等，使用char定长字符串类型。"}},[t._v("#")]),t._v(" 6. 【强制】如果存储的字符串长度相等，使用char定长字符串类型。")]),t._v(" "),e("h4",{attrs:{id:"_7-【强制】varchar是可变长字符串，不预先分配存储空间，长度不要超过5000。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-【强制】varchar是可变长字符串，不预先分配存储空间，长度不要超过5000。"}},[t._v("#")]),t._v(" 7. 【强制】varchar是可变长字符串，不预先分配存储空间，长度不要超过5000。")]),t._v(" "),e("p",[t._v("说明 ：如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。https://dev.mysql.com/doc/refman/5.7/en/char.html")]),t._v(" "),e("h4",{attrs:{id:"_8-【强制】主体表必备5个字段id、created-by、created-date、last-updated-by、last-update-date，关联关系表除外。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-【强制】主体表必备5个字段id、created-by、created-date、last-updated-by、last-update-date，关联关系表除外。"}},[t._v("#")]),t._v(" 8. 【强制】主体表必备5个字段id、created_by、created_date、last_updated_by、last_update_date，关联关系表除外。")]),t._v(" "),e("p",[t._v("说明：添加主键有利于主键更新删除等操作，当根据主键进行更新删除等操作时，不会锁全表；主从同步时，有利于提升同步效率；添加审计字段不管从安全角度还是后期故障排查都是很有意义的。")]),t._v(" "),e("h4",{attrs:{id:"_9-【强制】建表的时候每个字段必须添加字段注释-如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-【强制】建表的时候每个字段必须添加字段注释-如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。"}},[t._v("#")]),t._v(" 9. 【强制】建表的时候每个字段必须添加字段注释, 如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。")]),t._v(" "),e("h4",{attrs:{id:"_10-【强制】每个字段在设计时建议不要允许为null，而应该设计为not-null，可以给字段加上默认值，比如-数字类型default-0，字符类型default-；"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-【强制】每个字段在设计时建议不要允许为null，而应该设计为not-null，可以给字段加上默认值，比如-数字类型default-0，字符类型default-；"}},[t._v("#")]),t._v(' 10. 【强制】每个字段在设计时建议不要允许为null，而应该设计为not null，可以给字段加上默认值，比如:数字类型default 0，字符类型default ""；')]),t._v(" "),e("p",[t._v("说明：设计为null，在Mysql 需要多余一个字节去存储null值，同时对sql索引有影响，也就是索引字段 is null，是走不了索引的。")]),t._v(" "),e("h4",{attrs:{id:"_11-【强制】需要多表join的字段，数据类型保持绝对一致，可避免sql的隐式转换；"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-【强制】需要多表join的字段，数据类型保持绝对一致，可避免sql的隐式转换；"}},[t._v("#")]),t._v(" 11. 【强制】需要多表join的字段，数据类型保持绝对一致，可避免sql的隐式转换；")]),t._v(" "),e("p",[t._v("说明：隐式转换影响性能，避免不必要的性能损耗。")]),t._v(" "),e("h4",{attrs:{id:"_12-【推荐】表的命名最好是加上-t-业务简写-业务名称-xx-。主键id-使用-业务名称-xx-id"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-【推荐】表的命名最好是加上-t-业务简写-业务名称-xx-。主键id-使用-业务名称-xx-id"}},[t._v("#")]),t._v(' 12 【推荐】表的命名最好是加上“t_业务简写_业务名称_xx”。主键ID 使用"业务名称_xx_id"')]),t._v(" "),e("p",[t._v("正例：alipay_task / force_project / trade_config")]),t._v(" "),e("h4",{attrs:{id:"_13-【推荐】库名与应用名称尽量一致。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_13-【推荐】库名与应用名称尽量一致。"}},[t._v("#")]),t._v(" 13. 【推荐】库名与应用名称尽量一致。")]),t._v(" "),e("h4",{attrs:{id:"_14-【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_14-【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循："}},[t._v("#")]),t._v(" 14. 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：")]),t._v(" "),e("p",[t._v("1）不是频繁修改的字段。\n2）不是varchar超长字段，更不能是text字段。\n正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。")]),t._v(" "),e("h4",{attrs:{id:"_15-【推荐】单表行数超过500万行或者单表容量超过2gb，才推荐进行分库分表。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-【推荐】单表行数超过500万行或者单表容量超过2gb，才推荐进行分库分表。"}},[t._v("#")]),t._v(" 15. 【推荐】单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表。")]),t._v(" "),e("p",[t._v("说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。")]),t._v(" "),e("h4",{attrs:{id:"_16-【推荐】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-【推荐】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。"}},[t._v("#")]),t._v(" 16. 【推荐】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。")]),t._v(" "),e("p",[t._v("示例：年龄使用tinyint,性别(男/女)使用 char(2) 等。")]),t._v(" "),e("h4",{attrs:{id:"_17-【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_17-【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。"}},[t._v("#")]),t._v(" 17. 【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。")]),t._v(" "),e("p",[t._v("正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。")]),t._v(" "),e("h2",{attrs:{id:"三-索引建立基本原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三-索引建立基本原则"}},[t._v("#")]),t._v(" (三) 索引建立基本原则")]),t._v(" "),e("h4",{attrs:{id:"_1-【强制】禁止大字段建立索引-text-json-blob-。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-【强制】禁止大字段建立索引-text-json-blob-。"}},[t._v("#")]),t._v(" 1. 【强制】禁止大字段建立索引(text,json,blob) 。")]),t._v(" "),e("h4",{attrs:{id:"_2-【强制】禁止在区分度较低的字段上建立索引-可以结合其他字段建立组合索引，比如-在年龄字段上建立索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-【强制】禁止在区分度较低的字段上建立索引-可以结合其他字段建立组合索引，比如-在年龄字段上建立索引"}},[t._v("#")]),t._v(" 2. 【强制】禁止在区分度较低的字段上建立索引,可以结合其他字段建立组合索引，比如 : 在年龄字段上建立索引")]),t._v(" "),e("h4",{attrs:{id:"_3-【强制】主键索引名为pk-字段名；唯一索引名为uk-字段名；普通索引名则为idx-字段名。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-【强制】主键索引名为pk-字段名；唯一索引名为uk-字段名；普通索引名则为idx-字段名。"}},[t._v("#")]),t._v(" 3. 【强制】主键索引名为pk_字段名；唯一索引名为uk_字段名；普通索引名则为idx_字段名。")]),t._v(" "),e("p",[t._v("说明：pk_ 即primary key；uk_ 即 unique key；idx_ 即index的简称。")]),t._v(" "),e("h4",{attrs:{id:"_4-【推荐】最好不要在频繁更新的字段上建立索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-【推荐】最好不要在频繁更新的字段上建立索引"}},[t._v("#")]),t._v(" 4. 【推荐】最好不要在频繁更新的字段上建立索引")]),t._v(" "),e("h4",{attrs:{id:"_5-【参考】创建索引时避免有如下极端误解："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-【参考】创建索引时避免有如下极端误解："}},[t._v("#")]),t._v(" 5. 【参考】创建索引时避免有如下极端误解：")]),t._v(" "),e("p",[t._v("1） 宁滥勿缺。认为一个查询就需要建一个索引。\n2） 宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。\n3） 抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。")]),t._v(" "),e("h2",{attrs:{id:"四-索引规约"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四-索引规约"}},[t._v("#")]),t._v(" (四) 索引规约")]),t._v(" "),e("h4",{attrs:{id:"_1-【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。"}},[t._v("#")]),t._v(" 1. 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。")]),t._v(" "),e("p",[t._v("说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。")]),t._v(" "),e("h4",{attrs:{id:"_2-【强制】超过五个表禁止join【阿里限定3个表，考虑到业务复杂度，适量放宽】。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-【强制】超过五个表禁止join【阿里限定3个表，考虑到业务复杂度，适量放宽】。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。"}},[t._v("#")]),t._v(" 2. 【强制】超过五个表禁止join【阿里限定3个表，考虑到业务复杂度，适量放宽】。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。")]),t._v(" "),e("p",[t._v("说明：即使双表join也要注意表索引、SQL性能。")]),t._v(" "),e("h4",{attrs:{id:"_3-【强制】在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-【强制】在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。"}},[t._v("#")]),t._v(" 3. 【强制】在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。")]),t._v(" "),e("p",[t._v("说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会高达90%以上，可以使用count(distinct left(列名, 索引长度))/count(*)的区分度来确定。")]),t._v(" "),e("h4",{attrs:{id:"_4-【推荐】页面搜索尽量不要左模糊或者全模糊，如果需要请考虑搜索引擎来解决。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-【推荐】页面搜索尽量不要左模糊或者全模糊，如果需要请考虑搜索引擎来解决。"}},[t._v("#")]),t._v(" 4. 【推荐】页面搜索尽量不要左模糊或者全模糊，如果需要请考虑搜索引擎来解决。")]),t._v(" "),e("p",[t._v("说明：索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。")]),t._v(" "),e("h4",{attrs:{id:"_5-【推荐】如果有order-by的场景，请注意利用索引的有序性。order-by-最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file-sort的情况，影响查询性能。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-【推荐】如果有order-by的场景，请注意利用索引的有序性。order-by-最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file-sort的情况，影响查询性能。"}},[t._v("#")]),t._v(" 5. 【推荐】如果有order by的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。")]),t._v(" "),e("p",[t._v("正例：where a=? and b=? order by c; 索引：a_b_c\n反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a>10 ORDER BY b; 索引a_b无法排序。")]),t._v(" "),e("h4",{attrs:{id:"_6-【推荐】利用覆盖索引来进行查询操作，避免回表。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-【推荐】利用覆盖索引来进行查询操作，避免回表。"}},[t._v("#")]),t._v(" 6. 【推荐】利用覆盖索引来进行查询操作，避免回表。")]),t._v(" "),e("p",[t._v("说明：如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。\n正例：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用explain的结果，extra列会出现：using index。")]),t._v(" "),e("h4",{attrs:{id:"_7-【推荐】利用延迟关联或者子查询优化超多分页场景。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-【推荐】利用延迟关联或者子查询优化超多分页场景。"}},[t._v("#")]),t._v(" 7. 【推荐】利用延迟关联或者子查询优化超多分页场景。")]),t._v(" "),e("p",[t._v("说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。\n正例：先快速定位需要获取的id段，然后再关联：\nSELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id")]),t._v(" "),e("h4",{attrs:{id:"_8-【推荐】-sql性能优化的目标：至少要达到-range-级别，要求是ref级别，如果可以是consts最好。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-【推荐】-sql性能优化的目标：至少要达到-range-级别，要求是ref级别，如果可以是consts最好。"}},[t._v("#")]),t._v(" 8. 【推荐】 SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。")]),t._v(" "),e("p",[t._v("说明：\n1）consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。\n2）ref 指的是使用普通的索引（normal index）。\n3）range 对索引进行范围检索。\n反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。")]),t._v(" "),e("h4",{attrs:{id:"_9-【推荐】建组合索引的时候，区分度最高的在最左边。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-【推荐】建组合索引的时候，区分度最高的在最左边。"}},[t._v("#")]),t._v(" 9. 【推荐】建组合索引的时候，区分度最高的在最左边。")]),t._v(" "),e("p",[t._v("正例：如果where a=? and b=? ，如果a列的几乎接近于唯一值，那么只需要单建idx_a索引即可。\n说明：存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如：where c>? and d=? 那么即使c的区分度更高，也必须把d放在索引的最前列，即索引idx_d_c。")]),t._v(" "),e("h4",{attrs:{id:"_10-【推荐】使用explain判断sql语句是否合理使用索引，尽量避免extra列出现：using-file-sort，using-temporary。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-【推荐】使用explain判断sql语句是否合理使用索引，尽量避免extra列出现：using-file-sort，using-temporary。"}},[t._v("#")]),t._v(" 10. 【推荐】使用EXPLAIN判断SQL语句是否合理使用索引，尽量避免extra列出现：Using File Sort，Using Temporary。")]),t._v(" "),e("h2",{attrs:{id:"五-sql语句"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五-sql语句"}},[t._v("#")]),t._v(" (五) SQL语句")]),t._v(" "),e("h4",{attrs:{id:"_1-【强制】不要使用count-列名-或count-常量-来替代count-，count-是sql92定义的标准统计行数的语法，跟数据库无关，跟null和非null无关。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-【强制】不要使用count-列名-或count-常量-来替代count-，count-是sql92定义的标准统计行数的语法，跟数据库无关，跟null和非null无关。"}},[t._v("#")]),t._v(" 1. 【强制】不要使用count(列名)或count(常量)来替代count("),e("em",[t._v(")，count(")]),t._v(")是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关。")]),t._v(" "),e("p",[t._v("说明：count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。")]),t._v(" "),e("h4",{attrs:{id:"_2-【强制】count-distinct-col-计算该列除null之外的不重复行数，注意-count-distinct-col1-col2-如果其中一列全为null，那么即使另一列有不同的值，也返回为0。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-【强制】count-distinct-col-计算该列除null之外的不重复行数，注意-count-distinct-col1-col2-如果其中一列全为null，那么即使另一列有不同的值，也返回为0。"}},[t._v("#")]),t._v(" 2. 【强制】count(distinct col) 计算该列除NULL之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。")]),t._v(" "),e("h4",{attrs:{id:"_3-【强制】当某一列的值全是null时，count-col-的返回结果为0，但sum-col-的返回结果为null，因此使用sum-时需注意npe问题。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-【强制】当某一列的值全是null时，count-col-的返回结果为0，但sum-col-的返回结果为null，因此使用sum-时需注意npe问题。"}},[t._v("#")]),t._v(" 3. 【强制】当某一列的值全是NULL时，count(col)的返回结果为0，但sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题。")]),t._v(" "),e("p",[t._v("正例：可以使用如下方式来避免sum的NPE问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;")]),t._v(" "),e("h4",{attrs:{id:"_4-【强制】使用isnull-来判断是否为null值。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-【强制】使用isnull-来判断是否为null值。"}},[t._v("#")]),t._v(" 4. 【强制】使用ISNULL()来判断是否为NULL值。")]),t._v(" "),e("p",[t._v("说明：NULL与任何值的直接比较都为NULL。\n1） NULL<>NULL的返回结果是NULL，而不是false。\n2） NULL=NULL的返回结果是NULL，而不是true。\n3） NULL<>1的返回结果是NULL，而不是true。")]),t._v(" "),e("h4",{attrs:{id:"_5-【强制】-在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-【强制】-在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句。"}},[t._v("#")]),t._v(" 5. 【强制】 在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句。")]),t._v(" "),e("p",[t._v("说明：后续版本sahara框架统一优化")]),t._v(" "),e("h4",{attrs:{id:"_6-【强制】不得使用外键与级联，一切外键概念必须在应用层解决。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-【强制】不得使用外键与级联，一切外键概念必须在应用层解决。"}},[t._v("#")]),t._v(" 6. 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。")]),t._v(" "),e("p",[t._v("说明：以学生和成绩的关系为例，学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学生表中的student_id，同时触发成绩表中的student_id更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。")]),t._v(" "),e("h4",{attrs:{id:"_7-【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。"}},[t._v("#")]),t._v(" 7. 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。")]),t._v(" "),e("h4",{attrs:{id:"_8-【强制】数据订正（特别是删除、修改记录操作）时，要先select，避免出现误删除，确认无误才能执行更新语句。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-【强制】数据订正（特别是删除、修改记录操作）时，要先select，避免出现误删除，确认无误才能执行更新语句。"}},[t._v("#")]),t._v(" 8. 【强制】数据订正（特别是删除、修改记录操作）时，要先select，避免出现误删除，确认无误才能执行更新语句。")]),t._v(" "),e("h4",{attrs:{id:"_9-【强制】select语句只获取需要的字段，禁止使用select-from语句"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-【强制】select语句只获取需要的字段，禁止使用select-from语句"}},[t._v("#")]),t._v(" 9. 【强制】SELECT语句只获取需要的字段，禁止使用SELECT * FROM语句")]),t._v(" "),e("h4",{attrs:{id:"_10-【强制】insert语句必须显式的指明字段名称，不使用insert-into-table-value-；"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-【强制】insert语句必须显式的指明字段名称，不使用insert-into-table-value-；"}},[t._v("#")]),t._v(" 10. 【强制】INSERT语句必须显式的指明字段名称，不使用INSERT INTO table value()；")]),t._v(" "),e("p",[t._v("说明：避免后期因字段增减导致程序发生错误。")]),t._v(" "),e("h4",{attrs:{id:"_11-【强制】禁止在where子句中对字段施加函数，如to-date（add-time-xxxxx-应改为-add-time-unix-timestamp-date-add-str-to-date-20130227-y-m-d-interval-29-day-；"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-【强制】禁止在where子句中对字段施加函数，如to-date（add-time-xxxxx-应改为-add-time-unix-timestamp-date-add-str-to-date-20130227-y-m-d-interval-29-day-；"}},[t._v("#")]),t._v(" 11. 【强制】禁止在where子句中对字段施加函数，如to_date（add_time)>xxxxx,应改为:add_time >= unix_timestamp(date_add(str_to_date('20130227','%Y%m%d'),interval - 29 day))；")]),t._v(" "),e("p",[t._v("说明：对字段施加函数会导致无法走索引")]),t._v(" "),e("h4",{attrs:{id:"_12-【强制】写到应用程序里的sql语句，禁止一切ddl操作（如drop-table，create-table，truncate-table，临时表操作）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-【强制】写到应用程序里的sql语句，禁止一切ddl操作（如drop-table，create-table，truncate-table，临时表操作）"}},[t._v("#")]),t._v(" 12. 【强制】写到应用程序里的SQL语句，禁止一切DDL操作（如drop table，create table，truncate table，临时表操作）")]),t._v(" "),e("h4",{attrs:{id:"_13-【强制】不允许使用select-replace-uuid-from-xxx；"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_13-【强制】不允许使用select-replace-uuid-from-xxx；"}},[t._v("#")]),t._v(" 13. 【强制】不允许使用SELECT REPLACE(UUID() , '-', '') FROM XXX；")]),t._v(" "),e("p",[t._v("说明：SELECT REPLACE(UUID() , '-', '') FROM XXX拿到的uuid值都是一样的，可以使用SELECT REPLACE(CAST(UUID() as char) , '-', '') FROM XXX")]),t._v(" "),e("h4",{attrs:{id:"_14-【推荐】insert-select尽量不要用，会使用排它锁锁住select出来的那一部分数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_14-【推荐】insert-select尽量不要用，会使用排它锁锁住select出来的那一部分数据"}},[t._v("#")]),t._v(" 14. 【推荐】insert select尽量不要用，会使用排它锁锁住select出来的那一部分数据;")]),t._v(" "),e("h4",{attrs:{id:"_15-【推荐】避免多余的排序。比如使用group-by-时，默认会进行排序，当你不需要排序时，可以使用order-by-null"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-【推荐】避免多余的排序。比如使用group-by-时，默认会进行排序，当你不需要排序时，可以使用order-by-null"}},[t._v("#")]),t._v(" 15. 【推荐】避免多余的排序。比如使用GROUP BY 时，默认会进行排序，当你不需要排序时，可以使用order by null")]),t._v(" "),e("h4",{attrs:{id:"_16-【推荐】or-尽量少使用-关联查询容易引起数据暴增。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-【推荐】or-尽量少使用-关联查询容易引起数据暴增。"}},[t._v("#")]),t._v(" 16. 【推荐】OR 尽量少使用,关联查询容易引起数据暴增。")]),t._v(" "),e("h4",{attrs:{id:"_17-【推荐】in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000个之内。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_17-【推荐】in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000个之内。"}},[t._v("#")]),t._v(" 17. 【推荐】in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000个之内。")]),t._v(" "),e("h4",{attrs:{id:"_18-【参考】如果有国际化需要，所有的字符存储与表示，均以utf-8编码，注意字符统计函数的区别。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_18-【参考】如果有国际化需要，所有的字符存储与表示，均以utf-8编码，注意字符统计函数的区别。"}},[t._v("#")]),t._v(" 18. 【参考】如果有国际化需要，所有的字符存储与表示，均以utf-8编码，注意字符统计函数的区别。")]),t._v(" "),e("p",[t._v('说明：\nSELECT LENGTH("轻松工作")； 返回为12\nSELECT CHARACTER_LENGTH("轻松工作")； 返回为4\n如果需要存储表情，那么选择utf8mb4来进行存储，注意它与utf-8编码的区别。')]),t._v(" "),e("h4",{attrs:{id:"_19-【参考】-truncate-table-比-delete-速度快，且使用的系统和事务日志资源少，但truncate无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_19-【参考】-truncate-table-比-delete-速度快，且使用的系统和事务日志资源少，但truncate无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句。"}},[t._v("#")]),t._v(" 19. 【参考】 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但TRUNCATE无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句。")]),t._v(" "),e("p",[t._v("说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。\n说明：可以有效防止新增字段对应用逻辑的影响，还能减少对性能的影响")]),t._v(" "),e("h4",{attrs:{id:"_20-【参考】数据订正（特别是删除、-修改记录操作）-时，要先-select，避免出现误删除，确认无误才能执行更新语句。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_20-【参考】数据订正（特别是删除、-修改记录操作）-时，要先-select，避免出现误删除，确认无误才能执行更新语句。"}},[t._v("#")]),t._v(" 20. 【参考】数据订正（特别是删除、 修改记录操作） 时，要先 select，避免出现误删除，确认无误才能执行更新语句。")]),t._v(" "),e("h4",{attrs:{id:"_21-【参考】数据订正（特别是删除、-修改记录操作）-时，要先-select，避免出现误删除，确认无误才能执行更新语句。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_21-【参考】数据订正（特别是删除、-修改记录操作）-时，要先-select，避免出现误删除，确认无误才能执行更新语句。"}},[t._v("#")]),t._v(" 21. 【参考】数据订正（特别是删除、 修改记录操作） 时，要先 select，避免出现误删除，确认无误才能执行更新语句。")]),t._v(" "),e("h4",{attrs:{id:"_22-【参考】大批量数据更新-删除时，需要注意："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_22-【参考】大批量数据更新-删除时，需要注意："}},[t._v("#")]),t._v(" 22. 【参考】大批量数据更新/删除时，需要注意：")]),t._v(" "),e("p",[t._v('1）使用for循环更新/删除时，需要注意避免死锁；说明：不同的线程循环更新数据,数据中存在相同的数据,则会引起死锁/锁等待。\n2）使用事务保证一致性时，需要注意只有事务执行完成后，期间占用的锁才会释放；\n3）必须根据频次进行更新/删除，不然有可能撑爆临时表内存（每条连接有临时表内存限制），从而出现"the table XXX is full..."错误。')]),t._v(" "),e("h2",{attrs:{id:"六-orm映射"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#六-orm映射"}},[t._v("#")]),t._v(" (六) ORM映射")]),t._v(" "),e("h4",{attrs:{id:"_1-【强制】在表查询中，一律不要使用-作为查询的字段列表，需要哪些字段必须明确写明。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-【强制】在表查询中，一律不要使用-作为查询的字段列表，需要哪些字段必须明确写明。"}},[t._v("#")]),t._v(" 1. 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。")]),t._v(" "),e("p",[t._v("说明：1）增加查询分析器解析成本。2）增减字段容易与resultMap配置不一致。3）无用字段增加网络消耗，尤其是text类型的字段。")]),t._v(" "),e("h4",{attrs:{id:"_2-【强制】不要用resulttype当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个pojo类与之对应。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-【强制】不要用resulttype当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个pojo类与之对应。"}},[t._v("#")]),t._v(" 2. 【强制】不要用resultType当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个POJO类与之对应。")]),t._v(" "),e("p",[t._v("说明：配置映射关系，使字段与DO类解耦，方便维护。")]),t._v(" "),e("h4",{attrs:{id:"_3-【强制】mapper-xml配置参数使用：-，不要使用-此种方式容易出现sql注入。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-【强制】mapper-xml配置参数使用：-，不要使用-此种方式容易出现sql注入。"}},[t._v("#")]),t._v(" 3. 【强制】mapper.xml配置参数使用：#{}，不要使用${} 此种方式容易出现SQL注入。")]),t._v(" "),e("h4",{attrs:{id:"_4-【强制】不允许直接拿hashmap与hashtable作为查询结果集的输出。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-【强制】不允许直接拿hashmap与hashtable作为查询结果集的输出。"}},[t._v("#")]),t._v(" 4. 【强制】不允许直接拿HashMap与Hashtable作为查询结果集的输出。")]),t._v(" "),e("p",[t._v("说明：resultType=”java.utils.Map”，会置入字段名和属性值，但是值的类型不可控。")]),t._v(" "),e("h4",{attrs:{id:"_5-【强制】更新数据表记录时，必须同时更新记录对应的审计字段（实体类实现框架的auditable接口即可）；"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-【强制】更新数据表记录时，必须同时更新记录对应的审计字段（实体类实现框架的auditable接口即可）；"}},[t._v("#")]),t._v(" 5. 【强制】更新数据表记录时，必须同时更新记录对应的审计字段（实体类实现框架的Auditable接口即可）；")]),t._v(" "),e("h4",{attrs:{id:"_6-【强制】不要写一个大而全的数据更新接口。传入为pojo类，不管是不是自己的目标更新字段，都进行update-table-set-c1-value1-c2-value2-c3-value3-这是不对的。执行sql时，不要更新无改动的字段，一是易出错；二是效率低；三是增加binlog存储。特别在更新语句的使用容易产生全表更新。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-【强制】不要写一个大而全的数据更新接口。传入为pojo类，不管是不是自己的目标更新字段，都进行update-table-set-c1-value1-c2-value2-c3-value3-这是不对的。执行sql时，不要更新无改动的字段，一是易出错；二是效率低；三是增加binlog存储。特别在更新语句的使用容易产生全表更新。"}},[t._v("#")]),t._v(" 6. 【强制】不要写一个大而全的数据更新接口。传入为POJO类，不管是不是自己的目标更新字段，都进行update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加binlog存储。特别在更新语句的使用容易产生全表更新。")]),t._v(" "),e("h4",{attrs:{id:"_7-【参考】-transactional事务不要滥用。事务会影响数据库的qps，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-【参考】-transactional事务不要滥用。事务会影响数据库的qps，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。"}},[t._v("#")]),t._v(" 7. 【参考】@Transactional事务不要滥用。事务会影响数据库的QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。")]),t._v(" "),e("h4",{attrs:{id:"_8-【参考】-isequal-中的comparevalue是与属性值对比的常量，一般是数字，表示相等时带上此条件；-isnotempty-表示不为空且不为null时执行；-isnotnull-表示不为null值时执行。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-【参考】-isequal-中的comparevalue是与属性值对比的常量，一般是数字，表示相等时带上此条件；-isnotempty-表示不为空且不为null时执行；-isnotnull-表示不为null值时执行。"}},[t._v("#")]),t._v(" 8. 【参考】"),e("code",[t._v("<isEqual>")]),t._v("中的compareValue是与属性值对比的常量，一般是数字，表示相等时带上此条件；"),e("code",[t._v("<isNotEmpty>")]),t._v("表示不为空且不为null时执行；"),e("code",[t._v("<isNotNull>")]),t._v("表示不为null值时执行。")]),t._v(" "),e("h4",{attrs:{id:"_9-【参考】jdbc-url-地址最好可以使用域名，不要使用ip"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-【参考】jdbc-url-地址最好可以使用域名，不要使用ip"}},[t._v("#")]),t._v(" 9. 【参考】jdbc_url 地址最好可以使用域名，不要使用IP")]),t._v(" "),e("h2",{attrs:{id:"七-参考文献"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#七-参考文献"}},[t._v("#")]),t._v(" (七) 参考文献")]),t._v(" "),e("p",[t._v("阿里技术开发手册"),e("br"),t._v("\n美的数据库运维规范")])])}),[],!1,null,null,null);a.default=s.exports}}]);